<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>CatCoin Network</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#0a0a0a;color:#00ff41;font:11px monospace;overflow:hidden}
        canvas{display:block;margin:0 auto;border:1px solid #003300;background:radial-gradient(circle,#001100,#000000)}
        #ui{position:fixed;top:8px;left:8px;z-index:100;background:rgba(0,20,0,0.9);padding:8px;border:1px solid #003300;border-radius:4px}
        .stat{margin:2px 0;display:flex;align-items:center;gap:6px}
        .online{color:#00ff41}
        .offline{color:#ff4444}
        #wallet{position:fixed;top:8px;right:8px;background:rgba(0,20,0,0.9);padding:8px;border:1px solid #003300;border-radius:4px;min-width:200px}
        .coin{color:#ffaa00;font-weight:bold}
        #instructions{position:fixed;bottom:8px;right:8px;background:rgba(0,20,0,0.9);padding:8px;border:1px solid #003300;border-radius:4px;max-width:300px;font-size:9px}
        #level-complete{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,50,0,0.95);padding:20px;border:2px solid #00ff41;border-radius:8px;text-align:center;display:none}
        .mining{animation:pulse 1s infinite}
        @keyframes pulse{0%,100%{opacity:1}50%{opacity:0.5}}
        .node{stroke:#00ff41;stroke-width:2;fill:rgba(0,255,65,0.1)}
        .node.active{fill:rgba(0,255,65,0.3);stroke-width:3}
        .node.target{stroke:#ffaa00;stroke-width:4;fill:rgba(255,170,0,0.2)}
        .node.completed{fill:rgba(0,255,65,0.5)}
        .link{stroke:#003300;stroke-width:2}
        .link.active{stroke:#00ff41;stroke-width:3;animation:flow 1s infinite}
        @keyframes flow{0%{stroke-dashoffset:0}100%{stroke-dashoffset:10}}
        .cat{fill:#000;stroke:#00ff41;stroke-width:2}
        .shadow{fill:rgba(0,255,65,0.1)}
        .coin-particle{fill:#ffaa00}
        button{background:#1a472a;border:1px solid #00ff41;color:#00ff41;padding:8px 16px;margin:5px;border-radius:4px;cursor:pointer;font:11px monospace}
        button:hover{background:#2a573a}
    </style>
</head>
<body>
    <div id="ui">
        <div class="stat">üê± CatCoin Network</div>
        <div class="stat">üéØ Level: <span id="level">1</span></div>
        <div class="stat">‚è±Ô∏è Time: <span id="timer">0</span></div>
        <div class="stat mining">‚õèÔ∏è <span id="mining-status">Ready</span></div>
    </div>
    
    <div id="wallet">
        <div class="coin">üí∞ CatCoin: <span id="coins">0</span></div>
        <div style="font-size:9px;color:#666">Blocks Mined: <span id="blocks">0</span></div>
        <div style="font-size:9px;color:#666">Network Hash: <span id="hash">0</span></div>
    </div>
    
    <div id="instructions">
        <div>üìã OBJECTIVES:</div>
        <div>‚Ä¢ Move cats to mine all nodes</div>
        <div>‚Ä¢ Activate network connections</div>
        <div>‚Ä¢ Reach target node together</div>
        <div>‚Ä¢ Unlock blockchain rewards</div>
        <br>
        <div>üéÆ CONTROLS:</div>
        <div>‚Ä¢ Click adjacent nodes to move</div>
        <div>‚Ä¢ Mining takes time & energy</div>
        <div>‚Ä¢ Green = mined, Yellow = target</div>
    </div>
    
    <canvas id="game" width="800" height="600"></canvas>
    
    <div id="level-complete">
        <div style="font-size:16px;margin-bottom:10px">üéâ LEVEL COMPLETE!</div>
        <div>Network Successfully Mined!</div>
        <div style="margin:10px 0">
            <span>Coins Earned: </span><span class="coin" id="level-coins">0</span>
        </div>
        <button onclick="nextLevel()">Next Level</button>
        <button onclick="resetGame()">Restart</button>
    </div>

    <script>
        // Game state
        const game = {
            canvas: document.getElementById('game'),
            ctx: null,
            width: 800,
            height: 600,
            nodes: [],
            links: [],
            cats: [],
            level: 1,
            coins: 0,
            blocks: 0,
            startTime: Date.now(),
            levelComplete: false,
            particles: [],
            targetNodes: [],
            completedNodes: new Set(),
            networkHash: 0
        };

        game.ctx = game.canvas.getContext('2d');

        // Level configurations
        const levels = [
            {nodes: 6, cats: 1, targets: 1, time: 60, reward: 100},
            {nodes: 8, cats: 2, targets: 2, time: 90, reward: 200},
            {nodes: 10, cats: 2, targets: 3, time: 120, reward: 350},
            {nodes: 12, cats: 3, targets: 4, time: 150, reward: 500},
            {nodes: 14, cats: 3, targets: 5, time: 180, reward: 750}
        ];

        // Generate network topology for current level
        function generateLevel(level) {
            const config = levels[Math.min(level - 1, levels.length - 1)];
            game.nodes = [];
            game.links = [];
            game.cats = [];
            game.targetNodes = [];
            game.completedNodes.clear();
            game.levelComplete = false;
            game.startTime = Date.now();
            
            // Create nodes in organized pattern
            const nodeCount = config.nodes;
            const centerX = game.width / 2;
            const centerY = game.height / 2;
            
            // Central hub node
            game.nodes.push({
                id: 0,
                x: centerX,
                y: centerY,
                active: false,
                mined: false,
                mining: false,
                energy: Math.floor(Math.random() * 3) + 2,
                maxEnergy: Math.floor(Math.random() * 3) + 2,
                difficulty: 1
            });
            
            // Ring of nodes around center
            for(let i = 1; i < nodeCount; i++) {
                const ring = Math.floor((i - 1) / 6) + 1;
                const nodesInRing = Math.min(6, nodeCount - 1 - (ring - 1) * 6);
                const angleStep = (Math.PI * 2) / nodesInRing;
                const nodeInRing = (i - 1) % 6;
                const angle = angleStep * nodeInRing;
                const radius = 120 + ring * 80;
                
                game.nodes.push({
                    id: i,
                    x: centerX + Math.cos(angle) * radius + (Math.random() - 0.5) * 30,
                    y: centerY + Math.sin(angle) * radius + (Math.random() - 0.5) * 30,
                    active: false,
                    mined: false,
                    mining: false,
                    energy: Math.floor(Math.random() * 4) + 1,
                    maxEnergy: Math.floor(Math.random() * 4) + 1,
                    difficulty: ring
                });
            }

            // Create strategic links
            for(let i = 0; i < nodeCount; i++) {
                // Connect to center
                if(i > 0) {
                    game.links.push({from: 0, to: i, active: false});
                }
                
                // Connect to nearby nodes
                for(let j = i + 1; j < nodeCount; j++) {
                    const dx = game.nodes[i].x - game.nodes[j].x;
                    const dy = game.nodes[i].y - game.nodes[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if(distance < 180 && Math.random() > 0.4) {
                        if(!game.links.find(l => (l.from === i && l.to === j) || (l.from === j && l.to === i))) {
                            game.links.push({from: i, to: j, active: false});
                        }
                    }
                }
            }
            
            // Select target nodes (nodes that must be reached)
            const targetCount = config.targets;
            const possibleTargets = game.nodes.slice(Math.max(1, nodeCount - targetCount - 2));
            for(let i = 0; i < Math.min(targetCount, possibleTargets.length); i++) {
                game.targetNodes.push(possibleTargets[i].id);
            }
            
            // Create cats
            for(let i = 0; i < config.cats; i++) {
                game.cats.push(new NetworkCat(i, game.nodes[0].x, game.nodes[0].y));
            }
        }

        // Enhanced Cat entity with mining mechanics
        class NetworkCat {
            constructor(id, x, y) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.node = 0;
                this.moving = false;
                this.mining = false;
                this.miningProgress = 0;
                this.energy = 100;
                this.maxEnergy = 100;
                this.trail = [];
                this.color = ['#000', '#111', '#222'][id] || '#000';
            }

            update() {
                // Smooth movement
                if(this.moving) {
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if(distance > 3) {
                        this.x += dx * 0.15;
                        this.y += dy * 0.15;
                    } else {
                        this.x = this.targetX;
                        this.y = this.targetY;
                        this.moving = false;
                        this.startMining();
                    }
                }

                // Mining progress
                if(this.mining) {
                    const currentNode = game.nodes[this.node];
                    if(currentNode && !currentNode.mined && this.energy > 0) {
                        this.miningProgress += 1 + (this.energy / 100);
                        this.energy = Math.max(0, this.energy - 0.5);
                        
                        const requiredProgress = currentNode.difficulty * 60;
                        if(this.miningProgress >= requiredProgress) {
                            this.completeMining();
                        }
                        
                        // Create mining particles
                        if(Math.random() < 0.3) {
                            this.createMiningParticle();
                        }
                    }
                }

                // Energy regeneration when not mining
                if(!this.mining && this.energy < this.maxEnergy) {
                    this.energy += 0.3;
                }

                // Trail effect
                this.trail.push({x: this.x, y: this.y, alpha: 1});
                if(this.trail.length > 8) this.trail.shift();
                this.trail.forEach(t => t.alpha *= 0.85);
            }

            moveTo(nodeId) {
                if(this.mining || this.moving) return false;
                
                // Check if move is valid (connected nodes)
                const canMove = this.node === nodeId || game.links.some(l => 
                    (l.from === this.node && l.to === nodeId) || 
                    (l.to === this.node && l.from === nodeId)
                );
                
                if(canMove && nodeId < game.nodes.length) {
                    this.node = nodeId;
                    this.targetX = game.nodes[nodeId].x;
                    this.targetY = game.nodes[nodeId].y;
                    this.moving = true;
                    this.miningProgress = 0;
                    return true;
                }
                return false;
            }

            startMining() {
                const currentNode = game.nodes[this.node];
                if(currentNode && !currentNode.mined) {
                    this.mining = true;
                    currentNode.mining = true;
                    this.miningProgress = 0;
                    updateMiningStatus('Mining Node ' + this.node);
                }
            }

            completeMining() {
                const currentNode = game.nodes[this.node];
                if(currentNode) {
                    currentNode.mined = true;
                    currentNode.mining = false;
                    currentNode.active = true;
                    game.completedNodes.add(this.node);
                    
                    // Activate connected links
                    game.links.forEach(link => {
                        if((link.from === this.node || link.to === this.node) && 
                           (game.nodes[link.from].mined && game.nodes[link.to].mined)) {
                            link.active = true;
                        }
                    });
                    
                    // Reward calculation
                    const baseReward = currentNode.difficulty * 20;
                    const energyBonus = Math.floor(this.energy / 10) * 5;
                    const totalReward = baseReward + energyBonus;
                    
                    game.coins += totalReward;
                    game.blocks++;
                    game.networkHash += currentNode.difficulty * 1000;
                    
                    // Create reward particles
                    this.createRewardParticles(totalReward);
                    
                    updateUI();
                    checkLevelComplete();
                }
                
                this.mining = false;
                updateMiningStatus('Ready');
            }

            createMiningParticle() {
                game.particles.push({
                    x: this.x + (Math.random() - 0.5) * 20,
                    y: this.y + (Math.random() - 0.5) * 20,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2 - 1,
                    life: 30,
                    type: 'mining',
                    size: Math.random() * 3 + 1
                });
            }

            createRewardParticles(reward) {
                const particleCount = Math.min(reward / 10, 15);
                for(let i = 0; i < particleCount; i++) {
                    game.particles.push({
                        x: this.x,
                        y: this.y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8 - 2,
                        life: 60,
                        type: 'coin',
                        size: Math.random() * 4 + 2
                    });
                }
            }

            draw(ctx) {
                // Draw trail
                this.trail.forEach(t => {
                    ctx.globalAlpha = t.alpha * 0.4;
                    ctx.fillStyle = '#00ff41';
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                // Draw cat body
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - 8, this.y - 6, 16, 12);
                
                // Eyes
                ctx.fillStyle = '#00ff41';
                ctx.fillRect(this.x - 5, this.y - 3, 2, 2);
                ctx.fillRect(this.x + 3, this.y - 3, 2, 2);
                
                // Ears
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - 8, this.y - 10, 5, 5);
                ctx.fillRect(this.x + 3, this.y - 10, 5, 5);

                // Mining indicator
                if(this.mining) {
                    ctx.strokeStyle = '#ffaa00';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 15, 0, (this.miningProgress / (game.nodes[this.node].difficulty * 60)) * Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Energy bar
                const barWidth = 16;
                const barHeight = 2;
                ctx.fillStyle = '#330000';
                ctx.fillRect(this.x - barWidth/2, this.y + 10, barWidth, barHeight);
                ctx.fillStyle = this.energy > 30 ? '#00ff41' : '#ff4444';
                ctx.fillRect(this.x - barWidth/2, this.y + 10, (barWidth * this.energy) / this.maxEnergy, barHeight);

                // Cat ID
                ctx.fillStyle = '#00ff41';
                ctx.font = '8px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(this.id.toString(), this.x, this.y - 15);
            }
        }

        // Render game
        function render() {
            const ctx = game.ctx;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, game.width, game.height);

            // Draw network links
            game.links.forEach(link => {
                const from = game.nodes[link.from];
                const to = game.nodes[link.to];
                
                ctx.strokeStyle = link.active ? '#00ff41' : '#003300';
                ctx.lineWidth = link.active ? 3 : 2;
                
                if(link.active) {
                    ctx.setLineDash([5, 5]);
                    ctx.lineDashOffset = Date.now() / 100;
                } else {
                    ctx.setLineDash([]);
                }
                
                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);
                ctx.stroke();
            });
            ctx.setLineDash([]);

            // Draw nodes
            game.nodes.forEach((node, i) => {
                let fillStyle, strokeStyle, lineWidth;
                
                if(game.targetNodes.includes(i)) {
                    fillStyle = node.mined ? 'rgba(0,255,65,0.5)' : 'rgba(255,170,0,0.2)';
                    strokeStyle = node.mined ? '#00ff41' : '#ffaa00';
                    lineWidth = 4;
                } else if(node.mined) {
                    fillStyle = 'rgba(0,255,65,0.4)';
                    strokeStyle = '#00ff41';
                    lineWidth = 3;
                } else if(node.mining) {
                    fillStyle = 'rgba(255,170,0,0.3)';
                    strokeStyle = '#ffaa00';
                    lineWidth = 3;
                } else {
                    fillStyle = 'rgba(0,255,65,0.1)';
                    strokeStyle = '#00ff41';
                    lineWidth = 2;
                }
                
                ctx.fillStyle = fillStyle;
                ctx.strokeStyle = strokeStyle;
                ctx.lineWidth = lineWidth;
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, 18, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Node info
                ctx.fillStyle = strokeStyle;
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(i.toString(), node.x, node.y - 2);
                
                // Difficulty indicator
                ctx.font = '8px monospace';
                ctx.fillText('D' + node.difficulty, node.x, node.y + 8);
                
                // Energy indicator
                if(!node.mined) {
                    ctx.fillStyle = '#666';
                    ctx.fillText('E' + node.energy, node.x, node.y + 30);
                }
            });

            // Draw particles
            game.particles = game.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.1; // Gravity
                p.vx *= 0.98;
                p.vy *= 0.98;
                p.life--;
                
                ctx.globalAlpha = p.life / (p.type === 'coin' ? 60 : 30);
                ctx.fillStyle = p.type === 'coin' ? '#ffaa00' : '#00ff41';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                
                return p.life > 0;
            });
            ctx.globalAlpha = 1;

            // Draw cats
            game.cats.forEach(cat => cat.draw(ctx));
            
            // Draw level progress
            const totalNodes = game.nodes.length;
            const minedNodes = game.completedNodes.size;
            const targetNodesMined = game.targetNodes.filter(id => game.completedNodes.has(id)).length;
            
            ctx.fillStyle = 'rgba(0,20,0,0.9)';
            ctx.fillRect(10, game.height - 60, 200, 50);
            ctx.strokeStyle = '#003300';
            ctx.strokeRect(10, game.height - 60, 200, 50);
            
            ctx.fillStyle = '#00ff41';
            ctx.font = '10px monospace';
            ctx.textAlign = 'left';
            ctx.fillText(`Nodes Mined: ${minedNodes}/${totalNodes}`, 15, game.height - 45);
            ctx.fillText(`Targets: ${targetNodesMined}/${game.targetNodes.length}`, 15, game.height - 30);
            ctx.fillText(`Network: ${Math.floor((minedNodes/totalNodes) * 100)}% Complete`, 15, game.height - 15);
        }

        // Input handling
        game.canvas.addEventListener('click', (e) => {
            const rect = game.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Find clicked node
            const clickedNode = game.nodes.findIndex(node => {
                const dx = x - node.x;
                const dy = y - node.y;
                return Math.sqrt(dx * dx + dy * dy) < 25;
            });
            
            if(clickedNode >= 0) {
                // Move the cat with highest energy to clicked node
                const availableCat = game.cats
                    .filter(cat => !cat.moving && !cat.mining)
                    .sort((a, b) => b.energy - a.energy)[0];
                
                if(availableCat) {
                    availableCat.moveTo(clickedNode);
                }
            }
        });

        // Check level completion
        function checkLevelComplete() {
            const allTargetsMined = game.targetNodes.every(id => game.completedNodes.has(id));
            const allCatsAtTargets = game.cats.every(cat => game.targetNodes.includes(cat.node));
            
            if(allTargetsMined && allCatsAtTargets && !game.levelComplete) {
                game.levelComplete = true;
                
                const config = levels[Math.min(game.level - 1, levels.length - 1)];
                const timeBonus = Math.max(0, config.time - Math.floor((Date.now() - game.startTime) / 1000)) * 10;
                const levelReward = config.reward + timeBonus;
                
                game.coins += levelReward;
                updateUI();
                
                document.getElementById('level-coins').textContent = levelReward;
                document.getElementById('level-complete').style.display = 'block';
            }
        }

        // UI Updates
        function updateUI() {
            document.getElementById('level').textContent = game.level;
            document.getElementById('coins').textContent = game.coins;
            document.getElementById('blocks').textContent = game.blocks;
            document.getElementById('hash').textContent = game.networkHash.toLocaleString();
        }

        function updateMiningStatus(status) {
            document.getElementById('mining-status').textContent = status;
        }

        function updateTimer() {
            const elapsed = Math.floor((Date.now() - game.startTime) / 1000);
            document.getElementById('timer').textContent = elapsed + 's';
        }

        // Level management
        function nextLevel() {
            game.level++;
            generateLevel(game.level);
            document.getElementById('level-complete').style.display = 'none';
        }

        function resetGame() {
            game.level = 1;
            game.coins = 0;
            game.blocks = 0;
            game.networkHash = 0;
            generateLevel(1);
            document.getElementById('level-complete').style.display = 'none';
            updateUI();
        }

        // Game loop
        function gameLoop() {
            if(!game.levelComplete) {
                game.cats.forEach(cat => cat.update());
                updateTimer();
            }
            render();
            requestAnimationFrame(gameLoop);
        }

        // Initialize game
        generateLevel(1);
        updateUI();
        gameLoop();
        
        // Make functions globally accessible for buttons
        window.nextLevel = nextLevel;
        window.resetGame = resetGame;
    </script>
</body>
</html>